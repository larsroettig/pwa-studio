{
    "sourceFile": "packages/peregrine/lib/store/actions/cart/asyncActions.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1626094279572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626094334917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,11 @@\n             dispatch(actions.getCart.receive(cartId));\n             return;\n         }\n \n+        dispatch(actions.getCart.receive(\n+        return;\n \n-        return\n-\n         try {\n             // errors can come from graphql and are not thrown\n             const { data, errors } = await fetchCartId({\n                 fetchPolicy: 'no-cache'\n"
                },
                {
                    "date": 1626094342606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n             dispatch(actions.getCart.receive(cartId));\n             return;\n         }\n \n-        dispatch(actions.getCart.receive(\n+        dispatch(actions.getCart.receive(null));\n         return;\n \n         try {\n             // errors can come from graphql and are not thrown\n"
                },
                {
                    "date": 1626094389340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,9 @@\n             dispatch(actions.getCart.receive(cartId));\n             return;\n         }\n \n-        dispatch(actions.getCart.receive(null));\n-        return;\n-\n+       \n         try {\n             // errors can come from graphql and are not thrown\n             const { data, errors } = await fetchCartId({\n                 fetchPolicy: 'no-cache'\n"
                },
                {
                    "date": 1626094395228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,14 +24,12 @@\n             dispatch(actions.getCart.receive(cartId));\n             return;\n         }\n \n-       \n+\n         try {\n             // errors can come from graphql and are not thrown\n-            const { data, errors } = await fetchCartId({\n-                fetchPolicy: 'no-cache'\n-            });\n+            \n \n             let receivePayload;\n \n             if (errors) {\n"
                },
                {
                    "date": 1626094402500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,18 +27,18 @@\n \n \n         try {\n             // errors can come from graphql and are not thrown\n-            \n \n+\n             let receivePayload;\n \n             if (errors) {\n                 receivePayload = new Error(errors);\n             } else {\n                 receivePayload = data.cartId;\n                 // write to storage in the background\n-                saveCartId(data.cartId);\n+                saveCartId(null);\n             }\n \n             dispatch(actions.getCart.receive(receivePayload));\n         } catch (error) {\n"
                },
                {
                    "date": 1626094441496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n const storage = new BrowserPersistence();\n \n export const createCart = payload =>\n     async function thunk(dispatch, getState) {\n-        const { fetchCartId } = payload;\n+        \n         const { cart } = getState();\n \n         // if a cart already exists in the store, exit\n         if (cart.cartId) {\n@@ -34,9 +34,9 @@\n \n             if (errors) {\n                 receivePayload = new Error(errors);\n             } else {\n-                receivePayload = data.cartId;\n+                receivePayload = null;\n                 // write to storage in the background\n                 saveCartId(null);\n             }\n \n"
                },
                {
                    "date": 1626095285682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n const storage = new BrowserPersistence();\n \n export const createCart = payload =>\n     async function thunk(dispatch, getState) {\n-        \n+        const { fetchCartId } = payload;\n         const { cart } = getState();\n \n         // if a cart already exists in the store, exit\n         if (cart.cartId) {\n@@ -24,21 +24,22 @@\n             dispatch(actions.getCart.receive(cartId));\n             return;\n         }\n \n-\n         try {\n             // errors can come from graphql and are not thrown\n+            const { data, errors } = await fetchCartId({\n+                fetchPolicy: 'no-cache'\n+            });\n \n-\n             let receivePayload;\n \n             if (errors) {\n                 receivePayload = new Error(errors);\n             } else {\n-                receivePayload = null;\n+                receivePayload = data.cartId;\n                 // write to storage in the background\n-                saveCartId(null);\n+                saveCartId(data.cartId);\n             }\n \n             dispatch(actions.getCart.receive(receivePayload));\n         } catch (error) {\n"
                },
                {
                    "date": 1626095304693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,21 +369,9 @@\n \n                 // Clear cart data from Apollo cache\n                 await clearCartDataFromCache(apolloClient);\n \n-                // Create a new cart\n-                try {\n-                    await dispatch(\n-                        createCart({\n-                            fetchCartId\n-                        })\n-                    );\n-                } catch (error) {\n-                    // If creating a cart fails, all is not lost. Return so that the\n-                    // user can continue to at least browse the site.\n-                    return;\n-                }\n-\n+              \n                 // Retry this operation\n                 return thunk(...arguments);\n             }\n         }\n"
                },
                {
                    "date": 1626095310073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,21 @@\n \n                 // Clear cart data from Apollo cache\n                 await clearCartDataFromCache(apolloClient);\n \n-              \n+                // Create a new cart\n+                try {\n+                    await dispatch(\n+                        createCart({\n+                            fetchCartId\n+                        })\n+                    );\n+                } catch (error) {\n+                    // If creating a cart fails, all is not lost. Return so that the\n+                    // user can continue to at least browse the site.\n+                    return;\n+                }\n+\n                 // Retry this operation\n                 return thunk(...arguments);\n             }\n         }\n"
                },
                {
                    "date": 1626095381029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -325,20 +325,9 @@\n         const { isSignedIn } = user;\n \n         // if there isn't a cart, create one then retry this operation\n         if (!cartId) {\n-            try {\n-                await dispatch(\n-                    createCart({\n-                        fetchCartId\n-                    })\n-                );\n-            } catch (error) {\n-                // If creating a cart fails, all is not lost. Return so that the\n-                // user can continue to at least browse the site.\n-                return;\n-            }\n-            return thunk(...arguments);\n+         return;\n         }\n \n         // Once we have the cart id indicate that we are starting to make\n         // async requests for the details.\n@@ -369,20 +358,8 @@\n \n                 // Clear cart data from Apollo cache\n                 await clearCartDataFromCache(apolloClient);\n \n-                // Create a new cart\n-                try {\n-                    await dispatch(\n-                        createCart({\n-                            fetchCartId\n-                        })\n-                    );\n-                } catch (error) {\n-                    // If creating a cart fails, all is not lost. Return so that the\n-                    // user can continue to at least browse the site.\n-                    return;\n-                }\n \n                 // Retry this operation\n                 return thunk(...arguments);\n             }\n"
                },
                {
                    "date": 1626095387820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -316,9 +316,9 @@\n     };\n };\n \n export const getCartDetails = payload => {\n-    const { fetchCartId, fetchCartDetails } = payload;\n+    const { fetchCartDetails } = payload;\n \n     return async function thunk(dispatch, getState, { apolloClient }) {\n         const { cart, user } = getState();\n         const { cartId } = cart;\n"
                }
            ],
            "date": 1626094279572,
            "name": "Commit-0",
            "content": "import { clearCartDataFromCache } from '../../../Apollo/clearCartDataFromCache';\nimport BrowserPersistence from '../../../util/simplePersistence';\nimport { signOut } from '../user';\nimport actions from './actions';\n\nconst storage = new BrowserPersistence();\n\nexport const createCart = payload =>\n    async function thunk(dispatch, getState) {\n        const { fetchCartId } = payload;\n        const { cart } = getState();\n\n        // if a cart already exists in the store, exit\n        if (cart.cartId) {\n            return;\n        }\n\n        // Request a new cart.\n        dispatch(actions.getCart.request());\n\n        // if a cart exists in storage, act like we just received it\n        const cartId = await retrieveCartId();\n        if (cartId) {\n            dispatch(actions.getCart.receive(cartId));\n            return;\n        }\n\n\n        return\n\n        try {\n            // errors can come from graphql and are not thrown\n            const { data, errors } = await fetchCartId({\n                fetchPolicy: 'no-cache'\n            });\n\n            let receivePayload;\n\n            if (errors) {\n                receivePayload = new Error(errors);\n            } else {\n                receivePayload = data.cartId;\n                // write to storage in the background\n                saveCartId(data.cartId);\n            }\n\n            dispatch(actions.getCart.receive(receivePayload));\n        } catch (error) {\n            // If we are unable to create a cart, the cart can't function, so\n            // we forcibly throw so the upstream actions won't retry.\n            dispatch(actions.getCart.receive(error));\n            throw new Error('Unable to create cart');\n        }\n    };\n\nexport const addItemToCart = (payload = {}) => {\n    const {\n        addItemMutation,\n        fetchCartDetails,\n        fetchCartId,\n        item,\n        quantity,\n        parentSku\n    } = payload;\n\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.addItem.request(payload));\n\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        try {\n            const variables = {\n                cartId,\n                parentSku,\n                product: item,\n                quantity,\n                sku: item.sku\n            };\n\n            await addItemMutation({\n                variables\n            });\n\n            // 2019-02-07  Moved these dispatches to the success clause of\n            // addItemToCart. The cart should only open on success.\n            // In the catch clause, this action creator calls its own thunk,\n            // so a successful retry will wind up here anyway.\n            await dispatch(\n                getCartDetails({\n                    fetchCartId,\n                    fetchCartDetails\n                })\n            );\n            dispatch(actions.addItem.receive());\n        } catch (error) {\n            dispatch(actions.addItem.receive(error));\n\n            const shouldRetry = !error.networkError && isInvalidCart(error);\n\n            // Only retry if the cart is invalid or the cartId is missing.\n            if (shouldRetry) {\n                if (isSignedIn) {\n                    // Since simple persistence just deletes auth token without\n                    // informing Redux, we need to perform the sign out action\n                    // to reset the user and cart slices back to initial state.\n                    await dispatch(signOut());\n                } else {\n                    // Delete the cached ID from local storage and Redux.\n                    // In contrast to the save, make sure storage deletion is\n                    // complete before dispatching the error--you don't want an\n                    // upstream action to try and reuse the known-bad ID.\n                    await dispatch(removeCart());\n                }\n\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // and fetch details\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\n/**\n * Applies changes in options/quantity to a cart item.\n *\n * @param payload.cartItemId {Number} the id of the cart item we are updating\n * @param payload.item {Object} the new configuration item if changes are selected.\n * @param payload.quantity {Number} the quantity of the item being updated\n * @param payload.productType {String} 'ConfigurableProduct' or other.\n */\nexport const updateItemInCart = (payload = {}) => {\n    const {\n        cartItemId,\n        fetchCartDetails,\n        fetchCartId,\n        item,\n        productType,\n        quantity,\n        removeItem,\n        updateItem\n    } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.updateItem.request(payload));\n\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        try {\n            if (productType === 'ConfigurableProduct') {\n                // You _must_ remove before adding or risk deleting the item\n                // entirely if only quantity has been modified.\n                await dispatch(\n                    removeItemFromCart({\n                        item: {\n                            id: cartItemId\n                        },\n                        fetchCartDetails,\n                        fetchCartId,\n                        removeItem\n                    })\n                );\n                await dispatch(\n                    addItemToCart({\n                        ...payload\n                    })\n                );\n            } else {\n                // If the product is a simple product we can just use the\n                // updateCartItems graphql mutation.\n                await updateItem({\n                    variables: {\n                        cartId,\n                        itemId: cartItemId,\n                        quantity\n                    }\n                });\n                // The configurable product conditional dispatches actions that\n                // each call getCartDetails. For simple items we must request\n                // details after the mutation completes. This may change when\n                // we migrate to the `cart` query for details, away from REST.\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n            }\n\n            dispatch(actions.updateItem.receive());\n        } catch (error) {\n            dispatch(actions.updateItem.receive(error));\n\n            const shouldRetry = !error.networkError && isInvalidCart(error);\n            if (shouldRetry) {\n                // Delete the cached ID from local storage and Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // and fetch details\n                await dispatch(\n                    getCartDetails({\n                        fetchCartId,\n                        fetchCartDetails\n                    })\n                );\n\n                if (isSignedIn) {\n                    // The user is signed in and we just received their cart.\n                    // Retry this operation.\n                    return thunk(...arguments);\n                } else {\n                    // The user is a guest and just received a brand new (empty) cart.\n                    // Add the updated item to that cart.\n                    await dispatch(\n                        addItemToCart({\n                            ...payload\n                        })\n                    );\n                }\n            }\n        }\n    };\n};\n\nexport const removeItemFromCart = payload => {\n    const { item, fetchCartDetails, fetchCartId, removeItem } = payload;\n\n    return async function thunk(dispatch, getState) {\n        dispatch(actions.removeItem.request(payload));\n\n        const { cart } = getState();\n        const { cartId } = cart;\n\n        try {\n            await removeItem({\n                variables: {\n                    cartId,\n                    itemId: item.id\n                }\n            });\n\n            dispatch(actions.removeItem.receive());\n        } catch (error) {\n            dispatch(actions.removeItem.receive(error));\n\n            const shouldResetCart = !error.networkError && isInvalidCart(error);\n            if (shouldResetCart) {\n                // Delete the cached ID from local storage.\n                // The reducer handles clearing out the bad ID from Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n                // then create a new one\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n            }\n        }\n\n        await dispatch(\n            getCartDetails({\n                fetchCartId,\n                fetchCartDetails\n            })\n        );\n    };\n};\n\nexport const getCartDetails = payload => {\n    const { fetchCartId, fetchCartDetails } = payload;\n\n    return async function thunk(dispatch, getState, { apolloClient }) {\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        // if there isn't a cart, create one then retry this operation\n        if (!cartId) {\n            try {\n                await dispatch(\n                    createCart({\n                        fetchCartId\n                    })\n                );\n            } catch (error) {\n                // If creating a cart fails, all is not lost. Return so that the\n                // user can continue to at least browse the site.\n                return;\n            }\n            return thunk(...arguments);\n        }\n\n        // Once we have the cart id indicate that we are starting to make\n        // async requests for the details.\n        dispatch(actions.getDetails.request(cartId));\n\n        try {\n            const { data } = await fetchCartDetails({\n                variables: { cartId },\n                fetchPolicy: 'network-only'\n            });\n            const { cart: details } = data;\n\n            dispatch(actions.getDetails.receive({ details }));\n        } catch (error) {\n            dispatch(actions.getDetails.receive(error));\n\n            const shouldResetCart = !error.networkError && isInvalidCart(error);\n            if (shouldResetCart) {\n                if (isSignedIn) {\n                    // Since simple persistence just deletes auth token without\n                    // informing Redux, we need to perform the sign out action\n                    // to reset the user and cart slices back to initial state.\n                    await dispatch(signOut());\n                } else {\n                    // Delete the cached ID from local storage.\n                    await dispatch(removeCart());\n                }\n\n                // Clear cart data from Apollo cache\n                await clearCartDataFromCache(apolloClient);\n\n                // Create a new cart\n                try {\n                    await dispatch(\n                        createCart({\n                            fetchCartId\n                        })\n                    );\n                } catch (error) {\n                    // If creating a cart fails, all is not lost. Return so that the\n                    // user can continue to at least browse the site.\n                    return;\n                }\n\n                // Retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const removeCart = () =>\n    async function thunk(dispatch) {\n        // Clear the cartId from local storage.\n        await clearCartId();\n\n        // Clear the cart info from the redux store.\n        dispatch(actions.reset());\n    };\n\n/* helpers */\nexport async function retrieveCartId() {\n    return storage.getItem('cartId');\n}\n\nexport async function saveCartId(id) {\n    return storage.setItem('cartId', id);\n}\n\nexport async function clearCartId() {\n    return storage.removeItem('cartId');\n}\n\nasync function retrieveImageCache() {\n    return storage.getItem('imagesBySku') || {};\n}\n\nasync function saveImageCache(cache) {\n    return storage.setItem('imagesBySku', cache);\n}\n\nexport async function writeImageToCache(item = {}) {\n    const { media_gallery_entries: media, sku } = item;\n\n    if (sku) {\n        const image = media && (media.find(m => m.position === 1) || media[0]);\n\n        if (image) {\n            const imageCache = await retrieveImageCache();\n\n            // if there is an image and it differs from cache\n            // write to cache and save in the background\n            if (imageCache[sku] !== image) {\n                imageCache[sku] = image;\n                saveImageCache(imageCache);\n\n                return image;\n            }\n        }\n    }\n}\n\n// Returns true if the cart is invalid.\nfunction isInvalidCart(error) {\n    return !!(\n        error.graphQLErrors &&\n        error.graphQLErrors.find(\n            err =>\n                err.message.includes('Could not find a cart') ||\n                err.message.includes(\"The cart isn't active\") ||\n                err.message.includes(\n                    'The current user cannot perform operations on cart'\n                )\n        )\n    );\n}\n"
        }
    ]
}